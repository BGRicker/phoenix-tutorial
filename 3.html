<html>
	<head>

		<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap.min.css">

		<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/js/bootstrap.min.js"></script>

<link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>
		<link rel="stylesheet" href="style.css">


	</head>

	<body>
	<div class="col-xs-10 col-xs-offset-1">
		<h1>Lesson 3</h1>

		<h2>Setting up the database with Ecto</h2>


		<p>
		Ecto is the mechanism we're going to use to connect to our postgres database, which we created in Lesson 1.
		</p>

		<p>
		Ecto takes an approach that's different from ActiveRecord to how you'll deal with the database, but it does support database migrations.
		</p>

		<p>
			To start with we'll need to configure <code>postgrex</code> and <code>ecto</code> as both applications and dependencies.
		</p>

		<p>
		When you want to include a new project as a dependency in your application, you add the its to the <code>deps</code> section in <code>mix.exs</code>.  Add the following two lines into the file:
		</p>

<pre><code>defmodule Splurty.Mixfile do
  use Mix.Project

  def project do
    [app: :splurty,
     version: "0.0.1",
     elixir: "~> 1.0",
     elixirc_paths: ["lib", "web"],
     compilers: [:phoenix] ++ Mix.compilers,
     deps: deps]
  end

  # Configuration for the OTP application
  #
  # Type `mix help compile.app` for more information
  def application do
    [mod: {Splurty, []},
     applications: [:phoenix, :cowboy, :logger]]
  end

  # Specifies your project dependencies
  #
  # Type `mix help deps` for examples and options
  defp deps do
    [
     {:phoenix, "~> 0.8.0"},
     {:cowboy, "~> 1.0"},
     {:postgrex, ">= 0.0.0"},
     {:ecto, "~> 0.2.0"}
    ]
  end
end</code></pre>


<p>
Save the file.
</p>

<p>
Then run the command to fetch and install the dependencies:
</p>

<pre><code>mix do deps.get, compile</code></pre>

<p>
It should complete without giving you error messages.  That includes the dependencies in our application.
</p>

<p>
Elixir also has a concept of <code>Applications</code>.  Applications are separate processes from our main application that our web application will communicate with.
</p>

<p>
We'll also need to add both the <code>postgrex</code> and <code>ecto</code> applications to our application.
</p>

<pre><code>defmodule Splurty.Mixfile do
  use Mix.Project

  def project do
    [app: :splurty,
     version: "0.0.1",
     elixir: "~> 1.0",
     elixirc_paths: ["lib", "web"],
     compilers: [:phoenix] ++ Mix.compilers,
     deps: deps]
  end

  # Configuration for the OTP application
  #
  # Type `mix help compile.app` for more information
  def application do
    [mod: {Splurty, []},
     applications: [:phoenix, :cowboy, :logger, :postgrex, :ecto]]
  end

  # Specifies your project dependencies
  #
  # Type `mix help deps` for examples and options
  defp deps do
    [
     {:phoenix, "~> 0.8.0"},
     {:cowboy, "~> 1.0"},
     {:postgrex, ">= 0.0.0"},
     {:ecto, "~> 0.2.0"}
    ]
  end
end</code></pre>


<h3>Zooming Out: How Ecto Is Organized</h3>

<p>
For an in-depth analysis of how ecto works, check <a href="https://www.youtube.com/watch?v=SJRfujy9vLA">this talk by Jose Valim</a>, or the official documentation <a href="http://hexdocs.pm/ecto/">here</a>.
</p>

<p>
The part of the Ecto documentation that you'll want to know going in is that there are three main components to it.
</p>

<h4>Repo</h4>

<p>
Short for Repository, a repo is the connection to a database.  Ecto makes it easy to connect to multiple different database in a single application.
</p>

<h4>Model</h4>
<p>
Models make it easy to save items to our database and provides callbacks in the lifecycle of the object.
</p>

<h4>Queries</h4>

<p>
Unlike ActiveRecord, Ecto doesn't hide the querying so much.  The querying system is influenced by dot-net's <code>LINQ</code>.  Since Elixir's syntax supports macros, the library actually doesn't need any "Language Integration", in the same vein as LINQ.
</p>

<p>
The one critical difference between LINQ and Ecto is Ecto is exclusive to querying databases.  In LINQ the abstraction is moved to any type of collection (such as arrays, hashes, etc).  Ecto makes the claim that the relational algebra it supports should be available to databases, which it maps to intuitively, but should not provide the functionality for regular collections, since the data types are not optimized for those types of queries.
</p>

<h3>Building the Repo</h3>

<p>
Add a file in the <code>lib/splurty</code> folder called <code>repo.ex</code>.  This will define the repository we'll be using in the context of this web application.  Make the file look like this:
</p>

<pre><code>defmodule Repo do
  use Ecto.Repo, adapter: Ecto.Adapters.Postgres

  def conf do
    parse_url Application.get_env(:phoenix, :database)[:url]
  end

  def priv do
    app_dir(:splurty, "priv/repo")
  end
end
</code></pre>
<p>Save the file</p>
<p>
	This sets up the repo.  
</p>
<p>
	The <code>priv</code> method defines what folder should private ecto stuff go (for example ecto database migration files).
</p>


<p>
The <code>conf</code> method describes how we should connect to the database.  It's expecting a database connection string, for example something like: <code>ecto://postgres-user:postgres-password@localhost/database_name</code>.
</p>

<p>
In this method we're saying we should pull the database connection string information out of the application's configuration (<code>Mix.Config</code>).  We're looking ahead, and by putting this in the configuration it will be possible to deploy to heroku, or have production's database have a different username/password (or even be on a different physical machine).
</p>

<p>
Now let's setup the configuration for the file.  Add the following line to the bottom of <code>config/dev.exs</code>.
</p>

<pre><code>use Mix.Config

config :splurty, Splurty.Endpoint,
  http: [port: System.get_env("PORT") || 4000],
  debug_errors: true,
  cache_static_lookup: false

# Enables code reloading for development
config :phoenix, :code_reloader, true

# Do not include metadata nor timestamps in development logs
config :logger, :console, format: "[$level] $message\n"

config :phoenix, :database,
url: "ecto://ecto:password@localhost/splurty_development"
</code></pre>

<p>
Save the file.
</p>

<p>
This sets up most of Ecto's repo.  The core repo code will run in external erlang process however, so we'll to configure that process to work.
</p>

<p>
When dealing with multiple processes, both Erlang and Elixir use the concept of <code>Supervisors</code>, and this is how the code is considered <code>Fault Tolerant</code>, because we think about strategies to keep our processes running smoothly (and how to deal with exceptional cases), by default.
</p>

<p>
The core thought in the erlang community is that <strong>Exceptional Cases Should Crash the Process</strong>, and then supervisors will re-start a new process that isn't messed up.
</p>

<p>
The two most common types of supervisors are <code>one_for_one</code>, which indicates when a process crashes a new process should be spun up to replace it.  The stratgey <code>one_for_all</code> will restart all children whenever any process dies.
</p>

<p>
For more information about Elixir's supervision tree check the <a href="http://elixir-lang.org/getting_started/mix_otp/5.html">Elixir-Lang Supervisor and Application</a> documentation.
</p>

<p>
Let's build a supervisor that uses the <code>one_for_one</code> strategy, and starts our Web Application's Endpoints as well as the Repo.
</p>

<p>
Add a file called in the <code>lib/splurty</code> folder called <code>supervisor.ex</code> that looks like this:
</p>

<pre><code>defmodule Splurty.Supervisor do
  use Supervisor
  
  def start_link do
    :supervisor.start_link(__MODULE__, [])
  end
  
  def init([]) do
    # Adding repo to be sent into supervise
    tree = [
      worker(Repo, []),
      worker(Splurty.Endpoint, []),
    ]
    supervise(tree, strategy: :one_for_one)
  end
end
</code></pre>

<p>
This sets up a pretty standard supervisor for our application.
</p>

<p>
The <code>start_link</code> method you may notice starts the line with <code>:supervisor</code>. The code <code>:supervisor</code> indicates we are calling the method on the Erlang's supervisor module.  Elixir allows us to call Erlang code directly quite easily.
</p>

<p>
The <code>tree</code> indicates all the child processes we want this supervisor to monitor.
</p>

<p>
Finally, we need to tell our application to use this supervisor.
</p>

<p>
Edit the <code>lib/splurty.ex</code> file to point to this supervisor.
</p>

<pre><code>defmodule Splurty do
  use Application

  # See http://elixir-lang.org/docs/stable/elixir/Application.html
  # for more information on OTP Applications
  def start(_type, _args) do
    import Supervisor.Spec, warn: false
    
    Splurty.Supervisor.start_link
  end
  
  # Tell Phoenix to update the endpoint configuration
  # whenever the application is updated.
  def config_change(changed, _new, removed) do
    Splurty.Endpoint.config_change(changed, removed)
    :ok
  end
end
</code></pre>
<p>
Save the file.
</p>

<p>
This changes our application to use the Supervisor we just setup for the supervisor of the application.  It also builds a whole new supervisor file, rather than having the supervision code within the application start method.
</p>

<h3>Create a Database Migration</h3>

<p>
Just like ActiveRecord, changes to the database schema are managed through migrations.
</p>

<p>
Let's generate a new migration by running the mix command:
</p>

<pre><code>$ mix ecto.gen.migration Repo create_quotes</code></pre>

<p>
This should output text similar to the following when indicating files it generated:
</p>

<pre><code>* creating priv/repo/migrations
* creating priv/repo/migrations/20150124205648_create_quotes.exs
</code></pre>

<p>
Cool.  Let's open up the <code>XXXXX_create_quotes.ex</code> within the <code>priv/repo</code> folder.
</p>

<p>
You'll notice there are two methods.  A method for migrating up, and a method for rolling back.  Each is expected to return a string of SQL code that will run against the database. 
</p>

<p>
At this point, Ecto doesn't have a nice DSL style method to create and modify our database structure, so we'll need to put direct SQL commands.  The fact it deals with migrations though solves most of the complexity of database schema changes.
</p>

<p>
Let's edit this up to create a database table for <code>quotes</code> that has a <code>saying</code> and an <code>author</code>. 
</p>

<pre><code>defmodule Repo.Migrations.CreateQuotes do
  use Ecto.Migration

  def up do
    "CREATE TABLE quotes(id serial primary key, saying varchar(140), author varchar(140));"
  end

  def down do
    "DROP TABLE quotes;"
  end
end
</code></pre>

<p>
Save the file.
</p>

<p>
Execute the database migration by running the following command:
</p>

<pre><code>mix ecto.migrate Repo</code></pre>

<p>
It should output some text on the console that looks something like this:
</p>

<pre><code>[debug] CREATE TABLE IF NOT EXISTS schema_migrations (id serial primary key, version bigint) (404670µs)
[debug] SELECT version FROM schema_migrations (13173µs)
* running UP _build/dev/lib/splurty/priv/repo/migrations/20150124205648_create_quotes.exs
[debug] CREATE TABLE IF NOT EXISTS schema_migrations (id serial primary key, version bigint) (12836µs)
[debug] SELECT version FROM schema_migrations WHERE version = 20150124205648 (7710µs)
[debug] CREATE TABLE quotes(id serial primary key, saying varchar(140), author varchar(140)); (5369µs)
[debug] INSERT INTO schema_migrations(version) VALUES (20150124205648) (2352µs)
</code></pre>

<p>
Awesome!  Our database is setup!
</p>

<h3>Setting up the Model</h3>

<p>
Now that we have our database table setup, we can create the Quote model.  Add a file in <code>web/models</code> called <code>quote.ex</code> that looks like this:
</p>

<pre><code>defmodule Splurty.Quote do
  use Ecto.Model

  schema "quotes" do
    field :saying, :string
    field :author, :string
  end
end
</code></pre>

<p>
Save the file. 
</p>
<p>
 Notice how we have to explicitly tell the model, which fields it has and what table it is connected to.  
</p>


<h3>Storing a quote in our database</h3>

<p>
Let's add a quote in our database by using elixir's interactive console.
</p>

<p>
Run the following command to get into interactive elixir console:
</p>

<pre><code>$ iex -S mix</code></pre>

<p>
Once it boots up, let's build up quote specifying the key/value pairs for the quote and store it in a variable.
</p>

<pre><code>&gt; quote = %Splurty.Quote{saying: "Haters gonna hate.  Ain'ters gonna ain't.", author: "Dave Skylark"}</code></pre>

<p>
And we can extract the message from the quote in the map by access the <code>saying</code> field.
</p>

<pre><code>&gt; quote.saying </code></pre>

<p>
And we see the following output:
</p>

<pre><code>"Haters gunna hate.  Ain'ter gunna a'int."</code></pre>

<p>
Cool.  Now let's store this into our database (aka the Repo)
</p>

<pre><code>&gt; Repo.insert(quote)</code></pre>

<p>
When you run the command you should see something like the following output to the console:
</p>

<pre><code>[debug] INSERT INTO "quotes" ("author", "saying") VALUES ($1, $2) RETURNING "id" (347555µs)
%Splurty.Quote{author: "Dave Skylark", id: 1,
 saying: "Haters gonna hate.  Ain'ters gonna ain't."}</code></pre>

 <p>
We can load the item back from the database by running the following code.
 </p>

 <pre><code>quote2 = Repo.get(Splurty.Quote, 1)</code></pre>

 <p>
And we can update the author to be <code>James Franco</code> instead of <code>Dave Skylark</code> like this:
 </p>

 <pre><code>&gt; quote3 = %{quote2 | author: "James Franco"}
 &gt; Repo.update(quote3)</code></pre>
<p>
And finally we can remove the item from our database like this:
</p>

<pre><code>&gt; Repo.delete(quote3)</code></pre>

<p>
Sweet.  We know our database connection is working properly!  Press CTRL+C  twice to exit <code>iex</code>.
</p>

		<div class="text-center">
		<a href="4.html" class="btn btn-primary">Onward to Lesson 4</a>
		</div>


<div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'thefirehoseprojectelixirphoenix'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    
</div>

</div>

    <!--  Google Analytics Tracking Pixel -->
    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-49340848-1', 'thefirehoseproject.com');
  ga('send', 'pageview');

</script>



	</body>
</html>